<?php

namespace App\Livewire;

use App\Models\Assignment;
use App\Models\Vehicle;
use App\Models\Driver;
use App\Models\VehicleMileageReading;
use App\Services\OverlapCheckService;
use Livewire\Component;
use Livewire\Attributes\Validate;
use Livewire\Attributes\On;
use Livewire\Attributes\Computed;
use Carbon\Carbon;
use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
use Illuminate\Support\Facades\DB;

/**
 * ğŸ“ Composant Formulaire d'Affectation - Enterprise Grade
 *
 * FonctionnalitÃ©s selon spÃ©cifications:
 * - Validation temps rÃ©el avec dÃ©tection de conflits
 * - Auto-suggestions de crÃ©neaux libres
 * - Support durÃ©es indÃ©terminÃ©es (end_datetime = NULL)
 * - UX optimisÃ©e avec feedback visuel immÃ©diat
 * - AccessibilitÃ© WAI-ARIA complÃ¨te
 */
class AssignmentForm extends Component
{
    use AuthorizesRequests;

    // Props du composant
    public ?Assignment $assignment = null;
    public bool $isEditing = false;

    // DonnÃ©es du formulaire
    #[Validate('required|exists:vehicles,id')]
    public string $vehicle_id = '';

    #[Validate('required|exists:drivers,id')]
    public string $driver_id = '';

    // ğŸ†• SÃ‰PARATION DATE ET HEURE (ENTERPRISE V3)
    #[Validate('required|date')]
    public string $start_date = '';

    #[Validate('required|string')]
    public string $start_time = '08:00';

    #[Validate('nullable|date')]
    public string $end_date = '';

    #[Validate('nullable|string')]
    public string $end_time = '18:00';

    // PropriÃ©tÃ©s combinÃ©es (pour compatibilitÃ©)
    public string $start_datetime = '';
    public string $end_datetime = '';

    #[Validate('nullable|string|max:500')]
    public string $reason = '';

    #[Validate('nullable|string|max:1000')]
    public string $notes = '';

    // ğŸ†• KILOMÃ‰TRAGE AVEC MISE Ã€ JOUR DYNAMIQUE
    #[Validate('nullable|integer|min:0')]
    public ?int $start_mileage = null;

    public ?int $current_vehicle_mileage = null;
    public bool $updateVehicleMileage = true; // Par dÃ©faut, met Ã  jour le vÃ©hicule
    public bool $mileageModified = false;

    // Ã‰tat de validation
    public array $conflicts = [];
    public array $suggestions = [];
    public bool $hasConflicts = false;
    public bool $isValidating = false;
    public bool $forceCreate = false;

    // Options pour les selects
    public $vehicleOptions = [];
    public $driverOptions = [];

    protected OverlapCheckService $overlapService;

    public function boot(OverlapCheckService $overlapService)
    {
        $this->overlapService = $overlapService;
    }

    public function mount($assignmentId = null)
    {
        \Log::info('[ROOT AssignmentForm] mount() appelÃ© - app/Livewire/AssignmentForm.php', [
            'assignmentId' => $assignmentId,
            'assignmentId_type' => gettype($assignmentId)
        ]);

        if ($assignmentId) {
            \Log::info('[ROOT AssignmentForm] Mode Ã‰DITION dÃ©tectÃ©', ['assignmentId' => $assignmentId]);
            $this->assignment = Assignment::findOrFail($assignmentId);
            $this->isEditing = true;
            $this->authorize('update', $this->assignment);
            $this->fillFromAssignment($this->assignment);
        } else {
            \Log::info('[ROOT AssignmentForm] Mode CRÃ‰ATION dÃ©tectÃ© - Tentative authorize create');
            $this->authorize('create', Assignment::class);
            \Log::info('[ROOT AssignmentForm] âœ… AUTHORIZE PASSED!');
            $this->initializeNewAssignment();
        }

        \Log::info('[ROOT AssignmentForm] Avant loadOptions()');
        $this->loadOptions();
        \Log::info('[ROOT AssignmentForm] AprÃ¨s loadOptions() - mount() terminÃ© avec succÃ¨s');
    }

    public function render()
    {
        return view('livewire.assignment-form', [
            'vehicleOptions' => $this->vehicleOptions,
            'driverOptions' => $this->driverOptions,
        ]);
    }

    /**
     * Validation temps rÃ©el des conflits
     */
    public function updatedVehicleId()
    {
        // Charger le kilomÃ©trage actuel du vÃ©hicule sÃ©lectionnÃ©
        if ($this->vehicle_id) {
            $vehicle = Vehicle::find($this->vehicle_id);
            if ($vehicle) {
                $this->current_vehicle_mileage = $vehicle->current_mileage;
                // PrÃ©-remplir le kilomÃ©trage de dÃ©part si vide et pas encore modifiÃ©
                if ($this->start_mileage === null && $vehicle->current_mileage) {
                    $this->start_mileage = $vehicle->current_mileage;
                    $this->mileageModified = false;
                }
            }
        } else {
            $this->current_vehicle_mileage = null;
        }

        $this->combineDateTime();
        $this->validateAssignment();
    }

    /**
     * Mise Ã  jour directe lors de la sÃ©lection d'un vÃ©hicule (pour affichage immÃ©diat)
     */
    public function updatedVehicleIdLive()
    {
        // Charger le kilomÃ©trage actuel du vÃ©hicule sÃ©lectionnÃ© immÃ©diatement
        if ($this->vehicle_id) {
            $vehicle = Vehicle::find($this->vehicle_id);
            if ($vehicle) {
                $this->current_vehicle_mileage = $vehicle->current_mileage;
                // PrÃ©-remplir le kilomÃ©trage de dÃ©part si vide
                if ($this->start_mileage === null && $vehicle->current_mileage) {
                    $this->start_mileage = $vehicle->current_mileage;
                    $this->mileageModified = false;
                }
            }
        } else {
            $this->current_vehicle_mileage = null;
        }
    }

    public function updatedDriverId()
    {
        $this->combineDateTime();
        $this->validateAssignment();
    }

    // ğŸ†• WATCHERS POUR DATE/HEURE SÃ‰PARÃ‰ES
    public function updatedStartDate()
    {
        $this->combineDateTime();
        $this->validateAssignment();
    }

    public function updatedStartTime()
    {
        $this->combineDateTime();
        $this->validateAssignment();
    }

    public function updatedEndDate()
    {
        $this->combineDateTime();
        $this->validateAssignment();
    }

    public function updatedEndTime()
    {
        $this->combineDateTime();
        $this->validateAssignment();
    }

    public function updatedStartMileage()
    {
        $this->mileageModified = true;
    }

    /**
     * ğŸ”¥ ENTERPRISE GRADE: Charge le kilomÃ©trage du vÃ©hicule sans validation
     * MÃ©thode optimisÃ©e appelÃ©e par JavaScript lors de la sÃ©lection du vÃ©hicule
     *
     * @return void
     */
    public function loadVehicleMileage()
    {
        if (!$this->vehicle_id) {
            $this->current_vehicle_mileage = null;
            $this->start_mileage = null;
            return;
        }

        $vehicle = Vehicle::select('id', 'current_mileage')
            ->find($this->vehicle_id);

        if (!$vehicle) {
            \Log::warning('[AssignmentForm] VÃ©hicule non trouvÃ©', ['vehicle_id' => $this->vehicle_id]);
            $this->current_vehicle_mileage = null;
            $this->start_mileage = null;
            return;
        }

        // Mettre Ã  jour le kilomÃ©trage actuel du vÃ©hicule
        $this->current_vehicle_mileage = $vehicle->current_mileage ?? 0;

        // PrÃ©-remplir le kilomÃ©trage de dÃ©part si vide et pas encore modifiÃ©
        if ($this->start_mileage === null || !$this->mileageModified) {
            $this->start_mileage = $vehicle->current_mileage ?? 0;
            $this->mileageModified = false;
        }

        \Log::info('[AssignmentForm] KilomÃ©trage chargÃ©', [
            'vehicle_id' => $this->vehicle_id,
            'current_mileage' => $this->current_vehicle_mileage,
            'start_mileage' => $this->start_mileage,
        ]);
    }

    /**
     * ğŸ†• ENTERPRISE V3: Combine date et heure
     */
    private function combineDateTime(): void
    {
        // Combiner date et heure de dÃ©but
        if ($this->start_date && $this->start_time) {
            $this->start_datetime = $this->start_date . ' ' . $this->start_time;
        }

        // Combiner date et heure de fin (si prÃ©sentes)
        if ($this->end_date && $this->end_time) {
            $this->end_datetime = $this->end_date . ' ' . $this->end_time;
        } elseif (!$this->end_date) {
            $this->end_datetime = '';
        }
    }

    /**
     * Validation des conflits d'affectation
     */
    public function validateAssignment()
    {
        if (empty($this->vehicle_id) || empty($this->driver_id) || empty($this->start_datetime)) {
            $this->resetConflictsValidation();
            return;
        }

        $this->isValidating = true;

        try {
            $start = Carbon::parse($this->start_datetime);
            $end = $this->end_datetime ? Carbon::parse($this->end_datetime) : null;

            $result = $this->overlapService->checkOverlap(
                vehicleId: (int) $this->vehicle_id,
                driverId: (int) $this->driver_id,
                start: $start,
                end: $end,
                excludeId: $this->assignment?->id
            );

            $this->hasConflicts = $result['has_conflicts'];
            $this->conflicts = $result['conflicts'];
            $this->suggestions = $result['suggestions'];

            // Feedback visuel
            if ($this->hasConflicts) {
                $this->dispatch('conflicts-detected', [
                    'conflicts' => $this->conflicts,
                    'suggestions' => $this->suggestions
                ]);
            } else {
                $this->dispatch('conflicts-cleared');
            }

        } catch (\Exception $e) {
            $this->addError('validation', 'Erreur lors de la validation: ' . $e->getMessage());
        } finally {
            $this->isValidating = false;
        }
    }

    /**
     * Suggestions automatiques de crÃ©neaux
     */
    public function suggestNextSlot()
    {
        if (empty($this->vehicle_id) || empty($this->driver_id)) {
            $this->addError('suggestion', 'Veuillez sÃ©lectionner un vÃ©hicule et un chauffeur.');
            return;
        }

        $duration = $this->end_datetime ?
            Carbon::parse($this->start_datetime)->diffInHours(Carbon::parse($this->end_datetime)) :
            24; // DurÃ©e par dÃ©faut

        $slot = $this->overlapService->findNextAvailableSlot(
            vehicleId: (int) $this->vehicle_id,
            driverId: (int) $this->driver_id,
            durationHours: (int) $duration
        );

        if ($slot) {
            $this->start_datetime = $slot['start'];
            $this->end_datetime = $slot['end'];
            $this->validateAssignment();

            $this->dispatch('slot-suggested', [
                'message' => 'CrÃ©neau libre suggÃ©rÃ©: ' . $slot['start_formatted'] . ' - ' . $slot['end_formatted']
            ]);
        } else {
            $this->addError('suggestion', 'Aucun crÃ©neau libre trouvÃ© dans les 30 prochains jours.');
        }
    }

    /**
     * Appliquer une suggestion de crÃ©neau
     */
    public function applySuggestion(int $index)
    {
        if (isset($this->suggestions[$index])) {
            $suggestion = $this->suggestions[$index];
            $this->start_datetime = $suggestion['start'];
            $this->end_datetime = $suggestion['end'];
            $this->validateAssignment();

            $this->dispatch('suggestion-applied', [
                'message' => 'CrÃ©neau appliquÃ©: ' . $suggestion['description']
            ]);
        }
    }

    /**
     * Forcer la crÃ©ation malgrÃ© les conflits
     */
    public function toggleForceCreate()
    {
        $this->forceCreate = !$this->forceCreate;

        if ($this->forceCreate) {
            $this->dispatch('force-mode-enabled', [
                'message' => 'âš ï¸ Mode force activÃ© - Les conflits seront ignorÃ©s'
            ]);
        } else {
            $this->dispatch('force-mode-disabled');
        }
    }

    /**
     * Sauvegarde de l'affectation
     */
    public function save()
    {
        // Combiner date et heure avant validation
        $this->combineDateTime();

        // Validation Laravel standard
        $this->validate();

        // Validation mÃ©tier si pas en mode force
        if (!$this->forceCreate) {
            $validation = $this->overlapService->validateAssignment(
                vehicleId: (int) $this->vehicle_id,
                driverId: (int) $this->driver_id,
                start: Carbon::parse($this->start_datetime),
                end: $this->end_datetime ? Carbon::parse($this->end_datetime) : null,
                excludeId: $this->assignment?->id
            );

            if (!$validation['is_valid']) {
                foreach ($validation['errors'] as $error) {
                    $this->addError('business_validation', $error);
                }
                return;
            }
        }

        try {
            DB::beginTransaction();

            $data = [
                'organization_id' => auth()->user()->organization_id,
                'vehicle_id' => (int) $this->vehicle_id,
                'driver_id' => (int) $this->driver_id,
                'start_datetime' => Carbon::parse($this->start_datetime),
                'end_datetime' => $this->end_datetime ? Carbon::parse($this->end_datetime) : null,
                'start_mileage' => $this->start_mileage,
                'reason' => $this->reason ?: null,
                'notes' => $this->notes ?: null,
            ];

            if ($this->isEditing) {
                $this->assignment->update($data);
                $message = 'Affectation modifiÃ©e avec succÃ¨s.';
                $event = 'assignment-updated';
            } else {
                $this->assignment = Assignment::create($data);
                $message = 'Affectation crÃ©Ã©e avec succÃ¨s.';
                $event = 'assignment-created';
            }

            // ğŸ†• ENTERPRISE V3: Mise Ã  jour du kilomÃ©trage du vÃ©hicule avec historique
            if ($this->updateVehicleMileage && $this->start_mileage && $this->mileageModified) {
                $this->updateVehicleMileageWithHistory();
            }

            DB::commit();

            $this->dispatch($event, [
                'assignment' => $this->assignment,
                'message' => $message
            ]);

            // RÃ©initialiser si crÃ©ation
            if (!$this->isEditing) {
                $this->reset([
                    'vehicle_id', 'driver_id', 'start_date', 'start_time',
                    'end_date', 'end_time', 'start_datetime', 'end_datetime',
                    'start_mileage', 'reason', 'notes', 'forceCreate',
                    'mileageModified', 'updateVehicleMileage'
                ]);
                $this->resetConflictsValidation();
                parent::resetValidation();
                $this->current_vehicle_mileage = null;
            }

        } catch (\Exception $e) {
            DB::rollBack();
            $this->addError('save', 'Erreur lors de la sauvegarde: ' . $e->getMessage());
        }
    }

    /**
     * ğŸ†• ENTERPRISE V3: Met Ã  jour le kilomÃ©trage du vÃ©hicule et crÃ©e l'historique
     */
    private function updateVehicleMileageWithHistory(): void
    {
        $vehicle = Vehicle::find($this->vehicle_id);
        if (!$vehicle) return;

        $user = auth()->user();
        $oldMileage = $vehicle->current_mileage;

        // VÃ©rification que le nouveau kilomÃ©trage est supÃ©rieur
        if ($this->start_mileage <= $oldMileage) {
            throw new \Exception("Le kilomÃ©trage doit Ãªtre supÃ©rieur au kilomÃ©trage actuel ({$oldMileage} km)");
        }

        // Mettre Ã  jour le vÃ©hicule
        $vehicle->current_mileage = $this->start_mileage;
        $vehicle->save();

        // CrÃ©er l'entrÃ©e dans l'historique kilomÃ©trique (VehicleMileageReading)
        VehicleMileageReading::create([
            'organization_id' => $user->organization_id,
            'vehicle_id' => $vehicle->id,
            'recorded_at' => now(),
            'mileage' => $this->start_mileage,
            'recorded_by_id' => $user->id,
            'recording_method' => VehicleMileageReading::METHOD_MANUAL,
            'notes' => sprintf(
                'Mise Ã  jour lors de l\'affectation #%d - Ancien: %s km, Nouveau: %s km',
                $this->assignment->id,
                number_format($oldMileage),
                number_format($this->start_mileage)
            ),
        ]);

        \Log::info('[AssignmentForm] KilomÃ©trage mis Ã  jour', [
            'vehicle_id' => $vehicle->id,
            'old_mileage' => $oldMileage,
            'new_mileage' => $this->start_mileage,
            'assignment_id' => $this->assignment->id,
            'updated_by' => $user->id,
        ]);
    }

    /**
     * Duplication d'affectation existante
     */
    #[On('open-assignment-form')]
    public function handleOpenForm($data = [])
    {
        if (isset($data['prefill']) && $data['prefill']) {
            $this->vehicle_id = $data['vehicle_id'] ?? '';
            $this->driver_id = $data['driver_id'] ?? '';
            $this->start_datetime = $data['start_datetime'] ?? '';
            $this->reason = $data['reason'] ?? '';

            $this->validateAssignment();
        }
    }

    /**
     * MÃ©thodes utilitaires
     */
    private function fillFromAssignment(Assignment $assignment)
    {
        $this->vehicle_id = (string) $assignment->vehicle_id;
        $this->driver_id = (string) $assignment->driver_id;

        // SÃ©paration date et heure
        if ($assignment->start_datetime) {
            $this->start_date = $assignment->start_datetime->format('Y-m-d');
            $this->start_time = $assignment->start_datetime->format('H:i');
            $this->start_datetime = $assignment->start_datetime->format('Y-m-d H:i');
        }

        if ($assignment->end_datetime) {
            $this->end_date = $assignment->end_datetime->format('Y-m-d');
            $this->end_time = $assignment->end_datetime->format('H:i');
            $this->end_datetime = $assignment->end_datetime->format('Y-m-d H:i');
        } else {
            $this->end_date = '';
            $this->end_time = '18:00';
            $this->end_datetime = '';
        }

        $this->start_mileage = $assignment->start_mileage;
        $this->reason = $assignment->reason ?? '';
        $this->notes = $assignment->notes ?? '';

        // Charger le kilomÃ©trage actuel du vÃ©hicule
        if ($assignment->vehicle) {
            $this->current_vehicle_mileage = $assignment->vehicle->current_mileage;
        }

        $this->mileageModified = false;
    }

    private function initializeNewAssignment()
    {
        // Date de dÃ©but = demain
        $this->start_date = now()->addDay()->format('Y-m-d');
        $this->start_time = '08:00';

        // Fin vide par dÃ©faut (durÃ©e indÃ©terminÃ©e)
        $this->end_date = '';
        $this->end_time = '18:00';

        $this->reason = '';
        $this->notes = '';

        // Combiner les valeurs initiales
        $this->combineDateTime();

        $this->mileageModified = false;
    }

    private function loadOptions()
    {
        $organizationId = auth()->user()->organization_id;

        // CORRECTION ENTERPRISE V2: Utilisation des bons status_id et triple vÃ©rification
        $this->vehicleOptions = Vehicle::where('organization_id', $organizationId)
            ->where(function($query) {
                // VÃ©hicules au parking (disponibles) OU marquÃ©s comme disponibles
                $query->where('status_id', 8) // Parking
                      ->orWhere(function($q) {
                          $q->where('is_available', true)
                            ->where('assignment_status', 'available')
                            ->whereNull('current_driver_id');
                      });
            })
            ->where('is_archived', false)
            ->select('id', 'registration_plate', 'brand', 'model', 'current_mileage')
            ->orderBy('registration_plate')
            ->get();

        // CORRECTION ENTERPRISE V2: Support des statuts multiples pour les chauffeurs
        $this->driverOptions = Driver::where('organization_id', $organizationId)
            ->where(function($query) {
                // Chauffeurs avec statut Actif (1) OU Disponible (7) OU marquÃ©s comme disponibles
                $query->whereIn('status_id', [1, 7]) // Actif ou Disponible
                      ->orWhere(function($q) {
                          $q->where('is_available', true)
                            ->where('assignment_status', 'available')
                            ->whereNull('current_vehicle_id');
                      });
            })
            ->select('id', 'first_name', 'last_name', 'license_number')
            ->orderBy('last_name')
            ->get();
    }

    /**
     * RÃ©initialise l'Ã©tat de validation des conflits et suggestions
     * Note: Ne pas confondre avec resetValidation() native de Livewire
     */
    protected function resetConflictsValidation()
    {
        $this->conflicts = [];
        $this->suggestions = [];
        $this->hasConflicts = false;
        $this->isValidating = false;
    }

    /**
     * Getters pour la vue
     */
    public function getSelectedVehicleProperty()
    {
        return $this->vehicleOptions->firstWhere('id', $this->vehicle_id);
    }

    public function getSelectedDriverProperty()
    {
        return $this->driverOptions->firstWhere('id', $this->driver_id);
    }

    /**
     * ğŸ†• ENTERPRISE V3: GÃ©nÃ¨re les options de temps (30 min d'intervalle)
     */
    #[Computed]
    public function timeOptions(): array
    {
        $times = [];
        for ($hour = 0; $hour < 24; $hour++) {
            foreach (['00', '30'] as $minute) {
                $time = sprintf('%02d:%s', $hour, $minute);
                $times[] = [
                    'value' => $time,
                    'label' => $time
                ];
            }
        }
        return $times;
    }

    public function getDurationHoursProperty(): ?float
    {
        if (!$this->start_datetime || !$this->end_datetime) {
            return null;
        }

        try {
            $start = Carbon::parse($this->start_datetime);
            $end = Carbon::parse($this->end_datetime);
            return $start->diffInHours($end, true);
        } catch (\Exception $e) {
            return null;
        }
    }

    public function getFormattedDurationProperty(): string
    {
        $hours = $this->duration_hours;

        if ($hours === null) {
            return 'DurÃ©e indÃ©terminÃ©e';
        }

        if ($hours < 1) {
            return round($hours * 60) . ' min';
        }

        if ($hours < 24) {
            return round($hours, 1) . 'h';
        }

        $days = floor($hours / 24);
        $remainingHours = $hours % 24;

        return $days . 'j' . ($remainingHours > 0 ? ' ' . round($remainingHours, 1) . 'h' : '');
    }
}