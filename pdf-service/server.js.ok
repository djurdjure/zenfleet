import express from 'express';
import puppeteer from 'puppeteer';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import fs from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const app = express();
const port = process.env.PORT || 3000;

// Configuration du middleware avec des limites appropriées pour Express 5.x
app.use(express.json({ 
    limit: '50mb',
    strict: false // Express 5.x par défaut est plus strict
}));
app.use(express.urlencoded({ 
    extended: true, 
    limit: '50mb',
    parameterLimit: 1000 // Nouvelle option Express 5.x
}));

// Variables globales pour la gestion du navigateur
let browser = null;
let isShuttingDown = false;
let initializationPromise = null;

// Configuration Puppeteer optimisée pour la version 24.x
const puppeteerConfig = {
    headless: 'new', // Nouvelle syntaxe Puppeteer 24.x
    args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--disable-web-security',
        '--disable-features=VizDisplayCompositor',
        '--run-all-compositor-stages-before-draw',
        '--memory-pressure-off',
        '--max_old_space_size=1536',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding',
        '--no-first-run',
        '--no-default-browser-check',
        '--disable-extensions',
        '--disable-plugins',
        '--disable-images',
        '--disable-javascript', // Désactiver JS pour améliorer les performances PDF
        '--virtual-time-budget=30000' // Nouvelle option Puppeteer 24.x
    ],
    timeout: 30000,
    protocolTimeout: 30000,
    // Configuration spécifique à Puppeteer 24.x
    waitForInitialPage: false,
    ignoreDefaultArgs: ['--enable-automation']
};

// Fonction pour logger avec timestamp
function log(message, level = 'INFO') {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] [${level}] [ZenFleet PDF Service] ${message}`);
}

// Fonction pour initialiser le navigateur avec retry (compatible Puppeteer 24.x)
async function initBrowser(retries = 3) {
    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            log(`Tentative d'initialisation du navigateur (${attempt}/${retries})...`);
            
            // Puppeteer 24.x - Nouvelle méthode de lancement
            browser = await puppeteer.launch(puppeteerConfig);
            
            // Test de fonctionnement avec une page simple
            const testPage = await browser.newPage();
            
            // Configuration de la page pour Puppeteer 24.x
            await testPage.setViewport({ 
                width: 1200, 
                height: 800,
                deviceScaleFactor: 1,
                isMobile: false,
                hasTouch: false
            });
            
            // Test simple de rendu
            await testPage.setContent('<html><body><h1>Test Init</h1></body></html>', {
                waitUntil: 'domcontentloaded',
                timeout: 10000
            });
            
            await testPage.close();
            
            log('Navigateur initialisé avec succès');
            return true;
            
        } catch (error) {
            log(`Erreur lors de l'initialisation du navigateur (tentative ${attempt}): ${error.message}`, 'ERROR');
            
            if (browser) {
                try {
                    await browser.close();
                } catch (closeError) {
                    log(`Erreur lors de la fermeture du navigateur: ${closeError.message}`, 'WARN');
                }
                browser = null;
            }
            
            if (attempt < retries) {
                const waitTime = Math.pow(2, attempt) * 1000; // Backoff exponentiel
                log(`Attente de ${waitTime}ms avant la prochaine tentative...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
    }
    
    log('Impossible d\'initialiser le navigateur après toutes les tentatives', 'ERROR');
    return false;
}

// Fonction pour fermer proprement le navigateur
async function closeBrowser() {
    if (browser) {
        try {
            await browser.close();
            log('Navigateur fermé proprement');
        } catch (error) {
            log(`Erreur lors de la fermeture du navigateur: ${error.message}`, 'ERROR');
        }
        browser = null;
    }
}

// Middleware de logging des requêtes (compatible Express 5.x)
app.use((req, res, next) => {
    const start = Date.now();
    
    // Express 5.x - Nouvelle méthode pour les événements de réponse
    res.on('finish', () => {
        const duration = Date.now() - start;
        log(`${req.method} ${req.path} - ${res.statusCode} - ${duration}ms`);
    });
    
    next();
});

// Endpoint de santé amélioré pour Puppeteer 24.x
app.get('/health', async (req, res) => {
    const healthStatus = {
        status: 'ok',
        timestamp: new Date().toISOString(),
        uptime: Math.floor(process.uptime()),
        memory: process.memoryUsage(),
        browser: browser ? 'connected' : 'disconnected',
        version: '2.0.0',
        environment: process.env.NODE_ENV || 'development',
        express_version: '5.1.0',
        puppeteer_version: '24.14.0'
    };
    
    // Test rapide du navigateur si disponible
    if (browser) {
        try {
            const pages = await browser.pages();
            const version = await browser.version();
            
            healthStatus.browser_pages = pages.length;
            healthStatus.browser_version = version;
            healthStatus.browser_status = 'healthy';
        } catch (error) {
            healthStatus.browser_status = 'unhealthy';
            healthStatus.browser_error = error.message;
            healthStatus.status = 'degraded';
        }
    }
    
    const statusCode = healthStatus.status === 'ok' ? 200 : 503;
    res.status(statusCode).json(healthStatus);
});

// Endpoint de test simple
app.get('/test', (req, res) => {
    res.json({
        message: 'Service PDF ZenFleet opérationnel',
        timestamp: new Date().toISOString(),
        browser_available: browser !== null,
        express_version: '5.1.0',
        puppeteer_version: '24.14.0'
    });
});

// Endpoint principal de génération PDF (optimisé pour Express 5.x et Puppeteer 24.x)
app.post('/generate-pdf', async (req, res) => {
    if (isShuttingDown) {
        return res.status(503).json({ 
            error: 'Service en cours d\'arrêt',
            retry_after: 30
        });
    }

    const startTime = Date.now();
    let page = null;
    const requestId = Math.random().toString(36).substr(2, 9);

    try {
        const { html, options = {} } = req.body;

        if (!html) {
            return res.status(400).json({ 
                error: 'Le contenu HTML est requis',
                request_id: requestId
            });
        }

        log(`[${requestId}] Début de génération PDF (taille HTML: ${html.length} caractères)`);

        // Vérifier que le navigateur est disponible
        if (!browser) {
            log(`[${requestId}] Navigateur non disponible, tentative de réinitialisation...`);
            const initialized = await initBrowser();
            if (!initialized) {
                throw new Error('Impossible d\'initialiser le navigateur');
            }
        }

        // Créer une nouvelle page avec configuration optimisée pour Puppeteer 24.x
        page = await browser.newPage();
        
        // Configuration de la page pour Puppeteer 24.x
        await page.setViewport({ 
            width: 1200, 
            height: 800,
            deviceScaleFactor: 1,
            isMobile: false,
            hasTouch: false
        });

        // Puppeteer 24.x - Nouvelle méthode d'interception des requêtes
        await page.setRequestInterception(true);
        page.on('request', (request) => {
            const resourceType = request.resourceType();
            // Bloquer les ressources inutiles pour améliorer les performances
            if (['image', 'stylesheet', 'font', 'media'].includes(resourceType)) {
                request.abort();
            } else {
                request.continue();
            }
        });

        // Puppeteer 24.x - Options de navigation améliorées
        await page.setContent(html, { 
            waitUntil: 'domcontentloaded',
            timeout: 30000
        });

        // Attendre que le contenu soit complètement rendu
        await page.evaluateHandle('document.fonts.ready');

        // Options par défaut pour le PDF (compatibles Puppeteer 24.x)
        const pdfOptions = {
            format: 'A4',
            printBackground: true,
            margin: {
                top: '1cm',
                right: '1cm',
                bottom: '1cm',
                left: '1cm'
            },
            preferCSSPageSize: true,
            // Nouvelles options Puppeteer 24.x
            tagged: false, // Désactiver le PDF tagué pour améliorer les performances
            outline: false, // Désactiver les signets
            ...options
        };

        log(`[${requestId}] Génération du PDF avec les options:`, JSON.stringify(pdfOptions));
        
        // Générer le PDF avec Puppeteer 24.x
        const pdfBuffer = await page.pdf(pdfOptions);

        const duration = Date.now() - startTime;
        const sizeKB = Math.round(pdfBuffer.length / 1024 * 100) / 100;
        
        log(`[${requestId}] PDF généré avec succès en ${duration}ms, taille: ${sizeKB}KB`);

        // Headers de réponse optimisés pour Express 5.x
        res.set({
            'Content-Type': 'application/pdf',
            'Content-Length': pdfBuffer.length,
            'X-Generation-Time': `${duration}ms`,
            'X-Request-ID': requestId,
            'X-Express-Version': '5.1.0',
            'X-Puppeteer-Version': '24.14.0',
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
        });

        res.send(pdfBuffer);

    } catch (error) {
        const duration = Date.now() - startTime;
        log(`[${requestId}] Erreur lors de la génération PDF (${duration}ms): ${error.message}`, 'ERROR');

        // Déterminer le code d'erreur approprié
        let statusCode = 500;
        if (error.message.includes('timeout')) {
            statusCode = 408;
        } else if (error.message.includes('navigation')) {
            statusCode = 422;
        } else if (error.message.includes('Protocol error')) {
            statusCode = 503; // Service temporairement indisponible
        }

        res.status(statusCode).json({
            error: 'Erreur lors de la génération du PDF',
            message: error.message,
            request_id: requestId,
            duration: `${duration}ms`,
            timestamp: new Date().toISOString(),
            express_version: '5.1.0',
            puppeteer_version: '24.14.0'
        });
    } finally {
        // Fermer la page si elle a été créée
        if (page) {
            try {
                await page.close();
            } catch (error) {
                log(`[${requestId}] Erreur lors de la fermeture de la page: ${error.message}`, 'WARN');
            }
        }
    }
});

// Gestion des erreurs globales (Express 5.x)
app.use((error, req, res, next) => {
    log(`Erreur non gérée: ${error.message}`, 'ERROR');
    log(`Stack trace: ${error.stack}`, 'ERROR');
    
    if (!res.headersSent) {
        res.status(500).json({
            error: 'Erreur interne du serveur',
            message: error.message,
            timestamp: new Date().toISOString(),
            express_version: '5.1.0'
        });
    }
});

// Gestion des routes non trouvées (Express 5.x)
app.use('*', (req, res) => {
    res.status(404).json({
        error: 'Endpoint non trouvé',
        path: req.originalUrl,
        method: req.method,
        available_endpoints: [
            'GET /health - Vérification de l\'état du service',
            'GET /test - Test simple du service',
            'POST /generate-pdf - Génération de PDF'
        ],
        express_version: '5.1.0'
    });
});

// Gestion de l'arrêt propre
async function gracefulShutdown(signal) {
    log(`Signal ${signal} reçu, arrêt en cours...`);
    isShuttingDown = true;
    
    // Attendre un peu pour permettre aux requêtes en cours de se terminer
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    await closeBrowser();
    log('Arrêt terminé');
    process.exit(0);
}

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Gestion des erreurs non capturées
process.on('uncaughtException', (error) => {
    log(`Exception non capturée: ${error.message}`, 'ERROR');
    log(`Stack trace: ${error.stack}`, 'ERROR');
    gracefulShutdown('uncaughtException');
});

process.on('unhandledRejection', (reason, promise) => {
    log(`Promesse rejetée non gérée: ${reason}`, 'ERROR');
    log(`Promise: ${promise}`, 'ERROR');
});

// Démarrage du serveur
async function startServer() {
    try {
        log('Démarrage du service PDF ZenFleet...');
        log(`Version Node.js: ${process.version}`);
        log(`Version Express: 5.1.0`);
        log(`Version Puppeteer: 24.14.0`);
        log(`Environnement: ${process.env.NODE_ENV || 'development'}`);
        
        // Initialiser le navigateur au démarrage
        initializationPromise = initBrowser();
        const browserInitialized = await initializationPromise;
        
        if (!browserInitialized) {
            log('Impossible de démarrer sans navigateur', 'ERROR');
            process.exit(1);
        }

        // Démarrer le serveur HTTP avec Express 5.x
        const server = app.listen(port, '0.0.0.0', () => {
            log(`Service en écoute sur le port ${port}`);
            log(`Endpoints disponibles:`);
            log(`  - POST http://localhost:${port}/generate-pdf`);
            log(`  - GET  http://localhost:${port}/health`);
            log(`  - GET  http://localhost:${port}/test`);
            log('Service PDF ZenFleet prêt à recevoir des requêtes');
        });

        // Configuration du serveur pour Express 5.x
        server.timeout = 120000; // 2 minutes
        server.keepAliveTimeout = 65000;
        server.headersTimeout = 66000;
        server.requestTimeout = 120000; // Nouvelle option Express 5.x

    } catch (error) {
        log(`Erreur lors du démarrage: ${error.message}`, 'ERROR');
        process.exit(1);
    }
}

// Démarrer le serveur
startServer();

